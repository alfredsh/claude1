generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  password      String
  role          Role     @default(PATIENT)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  patientProfile  PatientProfile?
  doctorProfile   DoctorProfile?
  sentMessages    Message[]       @relation("SentMessages")
  receivedMessages Message[]      @relation("ReceivedMessages")
  consultations   Consultation[]  @relation("PatientConsultations")
  doctorConsultations Consultation[] @relation("DoctorConsultations")
  chatSessions    ChatSession[]
}

enum Role {
  PATIENT
  DOCTOR
  ADMIN
}

model PatientProfile {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName       String
  lastName        String
  dateOfBirth     DateTime?
  gender          String?
  height          Float?
  weight          Float?
  bloodType       String?
  phone           String?
  avatarUrl       String?

  allergies       String[]
  chronicDiseases String[]
  medications     String[]

  goals           String[]
  activityLevel   String?
  dietType        String?
  smokingStatus   String?
  alcoholUsage    String?
  sleepHours      Float?
  stressLevel     Int?

  labResults       LabResult[]
  medicalDocuments MedicalDocument[]
  healthMetrics    HealthMetric[]
  recommendations Recommendation[]
  supplements     Supplement[]
  nutritionLogs   NutritionLog[]
  geneticData     GeneticData?
  doctors         PatientDoctor[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model DoctorProfile {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName       String
  lastName        String
  specialization  String
  licenseNumber   String
  phone           String?
  avatarUrl       String?
  bio             String?
  experience      Int?

  // Extended public profile
  education           Json?    // [{degree, institution, year, specialty}]
  achievements        Json?    // [{title, year, issuer?}]
  certifications      Json?    // [{name, issuer, year}]
  languages           String[]
  consultationPrice   Float?
  isAcceptingPatients Boolean  @default(true)
  city                String?
  clinic              String?

  patients        PatientDoctor[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model LabResult {
  id              String   @id @default(uuid())
  patientId       String
  patient         PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  testName        String
  testDate        DateTime
  fileUrl         String?
  status          String   @default("pending")

  parameters      LabParameter[]
  aiInterpretation String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model LabParameter {
  id          String    @id @default(uuid())
  labResultId String
  labResult   LabResult @relation(fields: [labResultId], references: [id], onDelete: Cascade)

  name        String
  value       Float
  unit        String
  normalMin   Float?
  normalMax   Float?
  status      ParameterStatus @default(NORMAL)
}

enum ParameterStatus {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

model MedicalDocument {
  id           String   @id @default(uuid())
  patientId    String
  patient      PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  docType      String   // ECG | ULTRASOUND | CT | MRI | SPIROMETRY | XRAY | OTHER
  title        String
  docDate      DateTime
  fileUrl      String?
  aiSummary    String?
  measurements Json?    // structured key measurements (ECG intervals, spirometry values, organ sizes…)
  status       String   @default("pending") // pending | processing | completed | error

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model HealthMetric {
  id          String   @id @default(uuid())
  patientId   String
  patient     PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  type        String
  value       Float
  unit        String
  recordedAt  DateTime @default(now())
  note        String?
}

model Recommendation {
  id          String   @id @default(uuid())
  patientId   String
  patient     PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  category    String
  title       String
  description String
  priority    String   @default("medium")
  isRead      Boolean  @default(false)
  source      String   @default("ai")

  createdAt   DateTime @default(now())
}

model Supplement {
  id          String   @id @default(uuid())
  patientId   String
  patient     PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  name        String
  dosage      String
  frequency   String
  reason      String?
  startDate   DateTime?
  endDate     DateTime?
  isActive    Boolean  @default(true)
  prescribedBy String?

  createdAt   DateTime @default(now())
}

model NutritionLog {
  id          String   @id @default(uuid())
  patientId   String
  patient     PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  mealType    String
  foodName    String
  calories    Float?
  protein     Float?
  carbs       Float?
  fats        Float?
  fiber       Float?
  imageUrl    String?
  loggedAt    DateTime @default(now())
}

model GeneticData {
  id            String   @id @default(uuid())
  patientId     String   @unique
  patient       PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)

  rawData       Json?
  riskFactors   Json?
  traits        Json?
  aiAnalysis    String?
  uploadedAt    DateTime @default(now())
}

model Consultation {
  id          String   @id @default(uuid())
  patientId   String
  patient     User     @relation("PatientConsultations", fields: [patientId], references: [id])
  doctorId    String
  doctor      User     @relation("DoctorConsultations", fields: [doctorId], references: [id])

  status      ConsultationStatus @default(PENDING)
  type        String   @default("video")
  scheduledAt DateTime?
  notes       String?

  messages    Message[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum ConsultationStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Message {
  id             String   @id @default(uuid())
  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User     @relation("SentMessages", fields: [senderId], references: [id])
  recipientId    String
  recipient      User     @relation("ReceivedMessages", fields: [recipientId], references: [id])

  content        String
  isRead         Boolean  @default(false)

  createdAt      DateTime @default(now())
}

model PatientDoctor {
  id        String         @id @default(uuid())
  patientId String
  patient   PatientProfile @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctorId  String
  doctor    DoctorProfile  @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  createdAt DateTime       @default(now())

  @@unique([patientId, doctorId])
}

model ChatSession {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  title       String   @default("Новый чат")
  messages    Json     @default("[]")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
